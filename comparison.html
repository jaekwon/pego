<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Comparison between pego and LPeg</title>
		<style>
			body {
				background-color: #000;
				color: #FFF;
			}
			a {
				text-decoration: none;
				color: #87CEEB;
			}
			a:hover {
				text-decoration: underline;
			}
			.comparison td {
				padding: 0;
				vertical-align: top;
			}
			.comparison td pre {
				background-color: #333;
				color: #FFF;
				padding: 5px;
				margin: 0;
			}
			.separator {
			}
			.type {
				font-weight: bold;
				color: #BDB76B;
			}
			.value {
				color: #FFA0A0;
			}
			.keyword {
				font-weight: bold;
				color: #F0E68C;
			}
			.comment {
				color: #87CEEB;
			}
		</style>
	</head>
	<body>

		<h1 id="top">Comparison between pego and LPeg</h1>

		<ul class="toc">
			<li><a href="#1.Lowlevel">Low-level stuff</a></li>
			<ul>
				<li><a href="#1.1.Instructions">Instructions</a></li>
				<li><a href="#1.2.Captures">Captures</a></li>
			</ul>
			<li><a href="#2.Midlevel">Mid-level stuff</a></li>
			<ul>
				<li><a href="#2.1.Constructors">Constructors</a></li>
				<li><a href="#2.2.Captures">Captures</a></li>
				<li><a href="#2.3.Methods-operators">Methods/Operators</a></li>
			</ul>
			<li><a href="#3.Highlevel">High-level stuff</a></li>
			<ul>
				<li><a href="#3.1.PEG">PEG grammars and expressions</a></li>
			</ul>
		</ul>

		<h2 id="1.Lowlevel">Low-level stuff</h2>

		<p>Low-level stuff interpreted by the virtual machine.</p>

		<h3 id="1.1.Instructions">Instructions</h3>

		<table class="comparison">
			<tr>
				<th>LPeg</th>
				<th>pego</th>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IAny<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IAny <span class="keyword">struct</span> <span class="separator">{</span>
   count <span class="type">int</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IChar<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IChar <span class="keyword">struct</span> <span class="separator">{</span>
   char <span class="type">byte</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode ISet<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> ICharset <span class="keyword">struct</span> <span class="separator">{</span>
   mask <span class="separator">[</span><span class="value">8</span><span class="separator">]</span><span class="type">uint32</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode ISpan<span class="separator">;</span></pre></td>
				<td>To do</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IRet<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IReturn <span class="keyword">struct</span><span class="separator">{</span><span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IEnd<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IEnd <span class="keyword">struct</span><span class="separator">{</span><span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IChoice<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IChoice <span class="keyword">struct</span> <span class="separator">{</span>
   offset <span class="type">int</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IJmp<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IJump <span class="keyword">struct</span> <span class="separator">{</span>
   offset <span class="type">int</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode ICall<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> ICall <span class="keyword">struct</span> <span class="separator">{</span>
   offset <span class="type">int</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IOpenCall<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IOpenCall <span class="keyword">struct</span> <span class="separator">{</span>
   name string
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode ICommit<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> ICommit <span class="keyword">struct</span> <span class="separator">{</span>
   offset <span class="type">int</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IPartialCommit<span class="separator">;</span></pre></td>
				<td>
					<pre><span class="comment">// unimplemented</span>
<span class="keyword">type</span> IPartialCommit <span class="keyword">struct</span> <span class="separator">{</span>
   offset <span class="type">int</span>
<span class="separator">}</span></pre>
				</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IBackCommit<span class="separator">;</span></pre></td>
				<td>To do</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IFailTwice<span class="separator">;</span></pre></td>
				<td>To do</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IFail<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IFail <span class="keyword">struct</span><span class="separator">{</span><span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IGiveup<span class="separator">;</span></pre></td>
				<td>To do</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IFunc<span class="separator">;</span></pre></td>
				<td>Won't do</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IFullCapture<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IFullCapture <span class="keyword">struct</span> <span class="separator">{</span>
   capOffset <span class="type">int</span> 
   handler CaptureHandler
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IEmptyCapture<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IEmptyCapture <span class="keyword">struct</span> <span class="separator">{</span>
   capOffset <span class="type">int</span> 
   handler CaptureHandler
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IEmptyCaptureIdx<span class="separator">;</span></pre></td>
				<td>Undecided</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode IOpenCapture<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> IOpenCapture <span class="keyword">struct</span> <span class="separator">{</span>
   capOffset <span class="type">int</span> 
   handler CaptureHandler
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode ICloseCapture<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> ICloseCapture <span class="keyword">struct</span> <span class="separator">{</span>
   capOffset <span class="type">int</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> Opcode ICloseRunTime<span class="separator">;</span></pre></td>
				<td>Unknown</td>
			</tr>
		</table>
		<a href="#top">^top</a>

		<h3 id="1.2.Captures">Captures</h3>

		<table class="comparison">
			<tr>
				<th>LPeg</th>
				<th>pego</th>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cclose<span class="separator">;</span></pre></td>
				<td>Not needed</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cposition<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> PositionCapture <span class="keyword">struct</span><span class="separator">{</span><span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cconst<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> ConstCapture <span class="keyword">struct</span> <span class="separator">{</span>
   value <span class="keyword">interface</span><span class="separator">{</span><span class="separator">}</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cbackref<span class="separator">;</span></pre></td>
				<td>To do</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Carg<span class="separator">;</span></pre></td>
				<td>To do</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Csimple<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> SimpleCapture <span class="keyword">struct</span><span class="separator">{</span><span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Ctable<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> ListCapture <span class="keyword">struct</span><span class="separator">{</span><span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cfunction<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> FunctionCapture <span class="keyword">struct</span> <span class="separator">{</span>
   function func<span class="separator">(</span><span class="separator">[</span><span class="separator">]</span><span class="separator">*</span>CaptureResult<span class="separator">)</span> <span class="separator">(</span><span class="keyword">interface</span><span class="separator">{</span><span class="separator">}</span><span class="separator">,</span> <span class="type">os.Error</span><span class="separator">)</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cquery<span class="separator">;</span></pre></td>
				<td>To do</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cstring<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> StringCapture <span class="keyword">struct</span> <span class="separator">{</span>
   format <span class="type">string</span>
<span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Csubst<span class="separator">;</span></pre></td>
				<td><pre><span class="keyword">type</span> SubstCapture <span class="keyword">struct</span><span class="separator">{</span><span class="separator">}</span></pre></td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cfold<span class="separator">;</span></pre></td>
				<td>Undecided</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cruntime<span class="separator">;</span></pre></td>
				<td>What does this do?</td>
			</tr>
			<tr>
				<td><pre><span class="keyword">enum</span> CapKind Cgroup<span class="separator">;</span></pre></td>
				<td>What does this do?</td>
			</tr>
		</table>
		<a href="#top">^top</a>

		<h2 id="2.Midlevel">Mid-level stuff</h2>

		<p>Used for building patterns.</p>
		<a href="#top">^top</a>

		<h3 id="2.1.Constructors">Constructors</h3>

		<table class="comparison">
			<tr>
				<th>LPeg</th>
				<th>pogo</th>
				<th>Comment</th>
			</tr>
			<tr>
				<td><pre>lpeg.P(pattern)</pre></td>
				<td><pre>P(pattern)</pre></td>
				<td>Return the pattern unmodified</td>
			</tr>
			<tr>
				<td><pre>lpeg.P(string)</pre></td>
				<td><pre>Pat(string) = Lit(string)</pre></td>
				<td>Literal match</td>
			</tr>
			<tr>
				<td><pre>lpeg.P(number)</pre></td>
				<td><pre>Pat(number) = Any(number)</pre></td>
				<td>Match <tt>number</tt> of any character.</td>
			</tr>
			<tr>
				<td><pre>lpeg.P(-number)</pre></td>
				<td><pre>Pat(-number) = Not(Any(number))</pre></td>
				<td>Assert that there are not <tt>number</tt> of any character.</td>
			</tr>
			<tr>
				<td><pre>lpeg.P(true)</pre></td>
				<td><pre>Pat(true) = Succ()</pre></td>
				<td>Always match.</td>
			</tr>
			<tr>
				<td><pre>lpeg.P(false)</pre></td>
				<td><pre>Pat(false) = Fail()</pre></td>
				<td>Never match.</td>
			</tr>
			<tr>
				<td><pre>lpeg.P(table)</pre></td>
				<td><pre>Grm(string, map[string]*Pattern)</pre></td>
				<td>Compile a grammar.</td>
			</tr>
			<tr>
				<td><pre>lpeg.P(function)</pre></td>
				<td>Everything is a match-time capture. Should be changed.</td>
				<td>Match-time capture.</td>
			</tr>
			<tr>
				<td><pre>lpeg.R(...)</pre></td>
				<td>To do.</td>
				<td>Character ranges.</td>
			</tr>
			<tr>
				<td><pre>lpeg.S(string)</pre></td>
				<td><pre>Set(string)</pre></td>
				<td>Character set.</td>
			</tr>
			<tr>
				<td><pre>lpeg.V(string)</pre></td>
				<td><pre>Ref(string)</pre></td>
				<td>Non-terminal.</td>
			</tr>
			<tr>
				<td><pre>lpeg.locale([table])</pre></td>
				<td>Undecided</td>
				<td>Non-terminal.</td>
			</tr>
			<tr>
				<td><pre>lpeg.V(string)</pre></td>
				<td><pre>Ref(string)</pre></td>
				<td>Non-terminal.</td>
			</tr>
		</table>
		<a href="#top">^top</a>

		<h3 id="2.2.Captures">Captures</h3>

		<table class="comparison">
			<tr>
				<th>LPeg</th>
				<th>pego</th>
				<th>Comments</th>
			</tr>
			<tr>
				<td><pre>lpeg.C(pattern)</pre></td>
				<td><pre>Csimple(pattern) = pattern.Csimple()</pre></td>
				<td>Captures the matched substring.</td>
			</tr>
			<tr>
				<td><pre>lpeg.Carg(n)</pre></td>
				<td>Undecided</td>
				<td>Captures the <tt>n</tt>'th extra argument to the matching function.</td>
			</tr>
			<tr>
				<td><pre>lpeg.Cb(name)</pre></td>
				<td>To do</td>
				<td>Backreference.</td>
			</tr>
			<tr>
				<td><pre>lpeg.Cc(value)</pre></td>
				<td><pre>Cconst(value)</pre></td>
				<td>Captures the given value.</td>
			</tr>
			<tr>
				<td><pre>lpeg.Cf(patt, func)</pre></td>
				<td>Undecided</td>
				<td>Folding of func over the captures of <tt>patt</tt>.</td>
			</tr>
			<tr>
				<td><pre>lpeg.Cg(patt, [name])</pre></td>
				<td>Undecided</td>
				<td>The captures of <tt>patt</tt>, optinally tagged with <tt>name</tt>.</td>
			</tr>
			<tr>
				<td><pre>lpeg.Cp()</pre></td>
				<td><pre>Cposition()</pre></td>
				<td>Captures the input position.</td>
			</tr>
			<tr>
				<td><pre>lpeg.Cs(patt)</pre></td>
				<td><pre>Csubst(patt) = patt.Csubst()</pre></td>
				<td>Nested captures replaces their matches.</td>
			</tr>
			<tr>
				<td><pre>lpeg.Ct(patt)</pre></td>
				<td><pre>Clist(patt) = patt.Clist()</pre></td>
				<td>A table (list) with all captures from <tt>patt</tt>.</td>
			</tr>
			<tr>
				<td><pre>patt / string</pre></td>
				<td><pre>Cstring(patt, format)</pre></td>
				<td>The captures of <tt>patt</tt> are used as arguments to format a string.</td>
			</tr>
			<tr>
				<td><pre>patt / table</pre></td>
				<td>Todo</td>
				<td>The first capture of <tt>patt</tt> is used to index the table.</td>
			</tr>
			<tr>
				<td><pre>patt / function</pre></td>
				<td><pre>Cfunction(patt, func) = patt.Cfunction(func)</pre></td>
				<td>The captures of <tt>patt</tt> is used as arguments to the function.</td>
			</tr>
			<tr>
				<td><pre>lpeg.Cmt(patt, function)</pre></td>
				<td>Undecided</td>
				<td>Like <tt>patt / function</tt>, except that it is executed immediately.</td>
			</tr>
		</table>
		<a href="#top">^top</a>

		<h3 id="2.3.Methods-operators">Methods/Operators</h3>

		<table class="comparison">
			<tr>
				<th>LPeg</th>
				<th>pego</th>
				<th>Comment</th>
			</tr>
			<tr>
				<td><pre>#patt</pre></td>
				<td><pre>And(patt)</pre></td>
				<td>Assert that <tt>patt</tt> matches.</td>
			</tr>
			<tr>
				<td><pre>-patt</pre></td>
				<td><pre>Not(patt)</pre></td>
				<td></td>
			</tr>
			<tr>
				<td><pre>patt1 + patt2 + patt3</pre></td>
				<td><pre>Or(patt1,patt2,patt3) = patt1.Or(patt2,patt3)</pre></td>
				<td>Ordered choice.</td>
			</tr>
			<tr>
				<td><pre>patt1 - patt2</pre></td>
				<td><pre>Seq(Not(patt2),patt1) = patt1.Exc(patt2)</pre></td>
				<td></td>
			</tr>
			<tr>
				<td><pre>patt1 * patt2</pre></td>
				<td><pre>Seq(patt1,patt2)</pre></td>
				<td>Sequence of matches.</td>
			</tr>
			<tr>
				<td><pre>patt ^ n</pre></td>
				<td><pre>Rep(patt,min,max) = patt.Rep(min,max)</pre></td>
				<td>Repetition.</td>
			</tr>
		</table>
		<a href="#top">^top</a>

		<h2 id="3.Highlevel">High-level stuff</h2>

		<p>PEG grammar.</p>
		<a href="#top">^top</a>

		<h3 id="3.1.PEG">PEG grammar and expressions</h3>
		
		<table class="comparison">
			<tr>
				<th>LPeg</th>
				<th width="20%">pego</th>
				<th>Comment</th>
			</tr>
			<tr>
				<td><pre>(p)</pre></td>
				<td>To do</td>
				<td>Grouping.</td>
			</tr>
			<tr>
				<td><pre>&apos;string&apos;</pre></td>
				<td>To do</td>
				<td>Literal string.</td>
			</tr>
			<tr>
				<td><pre>&quot;string&quot;</pre></td>
				<td>To do</td>
				<td>Literal string.</td>
			</tr>
			<tr>
				<td><pre>[class]</pre></td>
				<td>To do</td>
				<td>Character class.</td>
			</tr>
			<tr>
				<td><pre>.</pre></td>
				<td>To do</td>
				<td>Any character.</td>
			</tr>
			<tr>
				<td><pre>%name</pre></td>
				<td>To do</td>
				<td>Predefined pattern.</td>
			</tr>
			<tr>
				<td><pre>&lt;name&gt;</pre></td>
				<td>To do</td>
				<td>Non-terminal.</td>
			</tr>
			<tr>
				<td><pre>{}</pre></td>
				<td>To do</td>
				<td>Position capture.</td>
			</tr>
			<tr>
				<td><pre>{ p }</pre></td>
				<td>To do</td>
				<td>Simple capture.</td>
			</tr>
			<tr>
				<td><pre>{: p :}</pre></td>
				<td>To do</td>
				<td>Anonymous group capture.</td>
			</tr>
			<tr>
				<td><pre>{:name: p :}</pre></td>
				<td>To do</td>
				<td>Named group capture.</td>
			</tr>
			<tr>
				<td><pre>{~ p ~}</pre></td>
				<td>To do</td>
				<td>Substitution capture.</td>
			</tr>
			<tr>
				<td><pre>=name</pre></td>
				<td>To do</td>
				<td>Back reference.</td>
			</tr>
			<tr>
				<td><pre>p ?</pre></td>
				<td>To do</td>
				<td>Optional match.</td>
			</tr>
			<tr>
				<td><pre>p *</pre></td>
				<td>To do</td>
				<td>Zero or more repetitions.</td>
			</tr>
			<tr>
				<td><pre>p +</pre></td>
				<td>To do</td>
				<td>One or more repetitions.</td>
			</tr>
			<tr>
				<td><pre>p ^ n</pre></td>
				<td>To do</td>
				<td>Exactly n repetitions.</td>
			</tr>
			<tr>
				<td><pre>p ^ +n</pre></td>
				<td>To do</td>
				<td>At least n repetitions.</td>
			</tr>
			<tr>
				<td><pre>p ^ -n</pre></td>
				<td>To do</td>
				<td>At most n repetitions.</td>
			</tr>
			<tr>
				<td><pre>p -&gt; &apos;string&apos;</pre></td>
				<td>To do</td>
				<td>String capture.</td>
			</tr>
			<tr>
				<td><pre>p -&gt; &quot;string&quot;</pre></td>
				<td>To do</td>
				<td>String capture.</td>
			</tr>
			<tr>
				<td><pre>p -&gt; {}</pre></td>
				<td>To do</td>
				<td>Table capture.</td>
			</tr>
			<tr>
				<td><pre>p -&gt; name</pre></td>
				<td>To do</td>
				<td>Function/query/string capture, with <tt>name</tt> pulled from elsewhere.</td>
			</tr>
			<tr>
				<td><pre>p =&gt; name</pre></td>
				<td>To do</td>
				<td>Match-time capture.</td>
			</tr>
			<tr>
				<td><pre>&amp; p</pre></td>
				<td>To do</td>
				<td>And predicate.</td>
			</tr>
			<tr>
				<td><pre>! p</pre></td>
				<td>To do</td>
				<td>Not predicate.</td>
			</tr>
			<tr>
				<td><pre>p1 p2</pre></td>
				<td>To do</td>
				<td>Sequence.</td>
			</tr>
			<tr>
				<td><pre>p1 / p2</pre></td>
				<td>To do</td>
				<td>Ordered choice.</td>
			</tr>
			<tr>
				<td><pre>name &lt;- p</pre></td>
				<td>To do</td>
				<td>Grammar</td>
			</tr>
		</table>
		<a href="#top">^top</a>

	</body>
</html>
